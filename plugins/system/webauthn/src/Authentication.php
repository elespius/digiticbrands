<?php
/**
 * @package         Joomla.Plugin
 * @subpackage      System.Webauthn
 *
 * @copyright   (C) 2020 Open Source Matters, Inc. <https://www.joomla.org>
 * @license         GNU General Public License version 2 or later; see LICENSE.txt
 */

namespace Joomla\Plugin\System\Webauthn;

// Protect from unauthorized access
\defined('_JEXEC') or die();

use Exception;
use Joomla\CMS\Application\CMSApplication;
use Joomla\CMS\Factory;
use Joomla\CMS\Language\Text;
use Joomla\CMS\Log\Log;
use Joomla\CMS\Session\Session;
use Joomla\CMS\Uri\Uri;
use Joomla\CMS\User\User;
use Joomla\Session\SessionInterface;
use Laminas\Diactoros\ServerRequestFactory;
use RuntimeException;
use Webauthn\AuthenticationExtensions\AuthenticationExtensionsClientInputs;
use Webauthn\AuthenticatorSelectionCriteria;
use Webauthn\PublicKeyCredentialCreationOptions;
use Webauthn\PublicKeyCredentialDescriptor;
use Webauthn\PublicKeyCredentialRequestOptions;
use Webauthn\PublicKeyCredentialRpEntity;
use Webauthn\PublicKeyCredentialSource;
use Webauthn\PublicKeyCredentialUserEntity;
use Webauthn\Server;

/**
 * Helper class to aid in credentials creation (link an authenticator to a user account)
 *
 * @since   __DEPLOY_VERSION__
 * @internal
 */
abstract class Authentication
{
	/**
	 * The credentials repository
	 *
	 * @var   CredentialRepository
	 * @since __DEPLOY_VERSION__
	 */
	protected static $credentialsRepository;

	/**
	 * Generate the public key creation options.
	 *
	 * This is used for the first step of attestation (key registration).
	 *
	 * The PK creation options and the user ID are stored in the session.
	 *
	 * @param   User  $user  The Joomla user to create the public key for
	 *
	 * @return  PublicKeyCredentialCreationOptions
	 *
	 * @throws  Exception
	 * @since   __DEPLOY_VERSION__
	 */
	public static function getPubKeyCreationOptions(User $user): PublicKeyCredentialCreationOptions
	{
		$publicKeyCredentialCreationOptions = self::getWebauthnServer()->generatePublicKeyCredentialCreationOptions(
			self::getUserEntity($user),
			PublicKeyCredentialCreationOptions::ATTESTATION_CONVEYANCE_PREFERENCE_NONE,
			self::getPubKeyDescriptorsForUser($user),
			new AuthenticatorSelectionCriteria(
				AuthenticatorSelectionCriteria::AUTHENTICATOR_ATTACHMENT_NO_PREFERENCE,
				false,
				AuthenticatorSelectionCriteria::USER_VERIFICATION_REQUIREMENT_PREFERRED
			),
			new AuthenticationExtensionsClientInputs
		);

		// Save data in the session
		$app = Factory::getApplication();
		/** @var Session $session */
		$session = $app->getSession();
		$session->set('plg_system_webauthn.publicKeyCredentialCreationOptions', base64_encode(serialize($publicKeyCredentialCreationOptions)));
		$session->set('plg_system_webauthn.registration_user_id', $user->id);

		return $publicKeyCredentialCreationOptions;
	}

	/**
	 * Get the public key request options.
	 *
	 * This is used in the first step of the assertion (login) flow.
	 *
	 * @param   User  $user  The Joomla user to get the PK request optiosn for
	 *
	 * @return  PublicKeyCredentialRequestOptions
	 *
	 * @throws  Exception
	 * @since   __DEPLOY_VERSION__
	 */
	public static function getPubkeyRequestOptions(User $user): ?PublicKeyCredentialRequestOptions
	{
		Log::add('Creating PK request options', Log::DEBUG, 'webauthn.system');
		$publicKeyCredentialRequestOptions = self::getWebauthnServer()->generatePublicKeyCredentialRequestOptions(
			PublicKeyCredentialRequestOptions::USER_VERIFICATION_REQUIREMENT_PREFERRED,
			self::getPubKeyDescriptorsForUser($user)
		);

		// Save in session. This is used during the verification stage to prevent replay attacks.
		Factory::getApplication()->getSession()
			->set('plg_system_webauthn.publicKeyCredentialRequestOptions', base64_encode(serialize($publicKeyCredentialRequestOptions)));

		return $publicKeyCredentialRequestOptions;
	}

	/**
	 * Validate the authenticator assertion.
	 *
	 * This is used in the second step of the assertion (login) flow. The server verifies that the
	 * assertion generated by the authenticator has not been tampered with.
	 *
	 * @param   string  $data  The data
	 * @param   User    $user  The user we are trying to log in
	 *
	 * @return  PublicKeyCredentialSource
	 *
	 * @throws Exception
	 * @since   __DEPLOY_VERSION__
	 */
	public static function validateAssertionResponse(string $data, User $user): PublicKeyCredentialSource
	{
		/** @var SessionInterface $session */
		$session = Factory::getApplication()->getSession();

		// Make sure the public key credential request options in the session are valid
		$encodedPkOptions                  = $session->get('plg_system_webauthn.publicKeyCredentialRequestOptions', null);
		$serializedOptions                 = base64_decode($encodedPkOptions);
		$publicKeyCredentialRequestOptions = unserialize($serializedOptions);

		if (!is_object($publicKeyCredentialRequestOptions)
			|| empty($publicKeyCredentialRequestOptions)
			|| !($publicKeyCredentialRequestOptions instanceof PublicKeyCredentialRequestOptions))
		{
			Log::add('Cannot retrieve valid plg_system_webauthn.publicKeyCredentialRequestOptions from the session', Log::NOTICE, 'webauthn.system');
			throw new RuntimeException(Text::_('PLG_SYSTEM_WEBAUTHN_ERR_CREATE_INVALID_LOGIN_REQUEST'));
		}

		$data = base64_decode($data);

		if (empty($data))
		{
			Log::add('No or invalid assertion data received from the browser', Log::NOTICE, 'webauthn.system');

			throw new RuntimeException(Text::_('PLG_SYSTEM_WEBAUTHN_ERR_CREATE_INVALID_LOGIN_REQUEST'));
		}

		return self::getWebauthnServer()->loadAndCheckAssertionResponse(
			$data,
			self::getPKCredentialRequestOptions(),
			self::getUserEntity($user),
			ServerRequestFactory::fromGlobals()
		);
	}

	/**
	 * Validate the authenticator attestation.
	 *
	 * This is used for the second step of attestation (key registration), when the user has
	 * interacted with the authenticator and we need to validate the legitimacy of its response.
	 *
	 * An exception will be returned on error. Also, under very rare conditions, you may receive
	 * NULL instead of a PublicKeyCredentialSource object which means that something was off in the
	 * returned data from the browser.
	 *
	 * @param   string  $data  The data
	 *
	 * @return  PublicKeyCredentialSource|null
	 *
	 * @throws  Exception
	 * @since   __DEPLOY_VERSION__
	 */
	public static function validateAttestationResponse(string $data): PublicKeyCredentialSource
	{
		/** @var CMSApplication $app */
		$app     = Factory::getApplication();
		$session = $app->getSession();

		// Retrieve the PublicKeyCredentialCreationOptions object created earlier and perform sanity checks
		$encodedOptions = $session->get('plg_system_webauthn.publicKeyCredentialCreationOptions', null);

		if (empty($encodedOptions))
		{
			Log::add('Cannot retrieve plg_system_webauthn.publicKeyCredentialCreationOptions from the session', Log::NOTICE, 'webauthn.system');

			throw new RuntimeException(Text::_('PLG_SYSTEM_WEBAUTHN_ERR_CREATE_NO_PK'));
		}

		/** @var PublicKeyCredentialCreationOptions|null $publicKeyCredentialCreationOptions */
		try
		{
			$publicKeyCredentialCreationOptions = unserialize(base64_decode($encodedOptions));
		}
		catch (Exception $e)
		{
			Log::add('The plg_system_webauthn.publicKeyCredentialCreationOptions in the session is invalid', Log::NOTICE, 'webauthn.system');
			$publicKeyCredentialCreationOptions = null;
		}

		if (!is_object($publicKeyCredentialCreationOptions) || !($publicKeyCredentialCreationOptions instanceof PublicKeyCredentialCreationOptions))
		{
			throw new RuntimeException(Text::_('PLG_SYSTEM_WEBAUTHN_ERR_CREATE_NO_PK'));
		}

		// Retrieve the stored user ID and make sure it's the same one in the request.
		$storedUserId = $session->get('plg_system_webauthn.registration_user_id', 0);
		$myUser       = $app->getIdentity() ?? new User;
		$myUserId     = $myUser->id;

		if (($myUser->guest) || ($myUserId != $storedUserId))
		{
			$message = sprintf('Invalid user! We asked the authenticator to attest user ID %d, the current user ID is %d', $storedUserId, $myUserId);
			Log::add($message, Log::NOTICE, 'webauthn.system');

			throw new RuntimeException(Text::_('PLG_SYSTEM_WEBAUTHN_ERR_CREATE_INVALID_USER'));
		}

		// We init the PSR-7 request object using Diactoros
		return self::getWebauthnServer()->loadAndCheckAttestationResponse(
			base64_decode($data),
			$publicKeyCredentialCreationOptions,
			ServerRequestFactory::fromGlobals()
		);
	}

	/**
	 * Try to find the site's favicon in the site's root, images, media, templates or current
	 * template directory.
	 *
	 * @return  string|null
	 *
	 * @since   __DEPLOY_VERSION__
	 */
	private static function getSiteIcon(): ?string
	{
		$filenames = [
			'apple-touch-icon.png',
			'apple_touch_icon.png',
			'favicon.ico',
			'favicon.png',
			'favicon.gif',
			'favicon.bmp',
			'favicon.jpg',
			'favicon.svg',
		];

		try
		{
			$paths = [
				'/',
				'/images/',
				'/media/',
				'/templates/',
				'/templates/' . Factory::getApplication()->getTemplate(),
			];
		}
		catch (Exception $e)
		{
			return null;
		}

		foreach ($paths as $path)
		{
			foreach ($filenames as $filename)
			{
				$relFile  = $path . $filename;
				$filePath = JPATH_BASE . $relFile;

				if (is_file($filePath))
				{
					break 2;
				}

				$relFile = null;
			}
		}

		if (!isset($relFile) || \is_null($relFile))
		{
			return null;
		}

		return rtrim(Uri::base(), '/') . '/' . ltrim($relFile, '/');
	}

	/**
	 * Returns a User Entity object given a Joomla user
	 *
	 * @param   User  $user  The Joomla user to get the user entity for
	 *
	 * @return  PublicKeyCredentialUserEntity
	 *
	 * @since   __DEPLOY_VERSION__
	 */
	private static function getUserEntity(User $user): PublicKeyCredentialUserEntity
	{
		$repository = self::getCredentialsRepository();

		return new PublicKeyCredentialUserEntity(
			$user->username,
			$repository->getHandleFromUserId($user->id),
			$user->name,
			self::getAvatar($user, 64)
		);
	}

	/**
	 * Get the user's avatar (through Gravatar)
	 *
	 * @param   User  $user  The Joomla user object
	 * @param   int   $size  The dimensions of the image to fetch (default: 64 pixels)
	 *
	 * @return  string  The URL to the user's avatar
	 *
	 * @since   __DEPLOY_VERSION__
	 */
	private static function getAvatar(User $user, int $size = 64)
	{
		$scheme    = Uri::getInstance()->getScheme();
		$subdomain = ($scheme == 'https') ? 'secure' : 'www';

		return sprintf('%s://%s.gravatar.com/avatar/%s.jpg?s=%u&d=mm', $scheme, $subdomain, md5($user->email), $size);
	}

	/**
	 * Returns an array of the PK credential descriptors (registered authenticators) for the given
	 * user.
	 *
	 * @param   User  $user  The Joomla user to get the PK descriptors for
	 *
	 * @return  PublicKeyCredentialDescriptor[]
	 *
	 * @since   __DEPLOY_VERSION__
	 */
	private static function getPubKeyDescriptorsForUser(User $user): array
	{
		$userEntity  = self::getUserEntity($user);
		$repository  = self::getCredentialsRepository();
		$descriptors = [];
		$records     = $repository->findAllForUserEntity($userEntity);

		foreach ($records as $record)
		{
			$descriptors[] = $record->getPublicKeyCredentialDescriptor();
		}

		return $descriptors;
	}

	/**
	 * Retrieve the public key credential request options saved in the session.
	 *
	 * If they do not exist or are corrupt it is a hacking attempt and we politely tell the
	 * attacker to go away.
	 *
	 * @return  PublicKeyCredentialRequestOptions
	 *
	 * @throws  Exception
	 * @since   __DEPLOY_VERSION__
	 */
	private static function getPKCredentialRequestOptions(): PublicKeyCredentialRequestOptions
	{
		/** @var SessionInterface $session */
		$session = Factory::getApplication()->getSession();
		$encodedOptions = $session->get('plg_system_webauthn.publicKeyCredentialRequestOptions', null);

		if (empty($encodedOptions))
		{
			Log::add('Cannot retrieve plg_system_webauthn.publicKeyCredentialRequestOptions from the session', Log::NOTICE, 'webauthn.system');

			throw new RuntimeException(Text::_('PLG_SYSTEM_WEBAUTHN_ERR_CREATE_INVALID_LOGIN_REQUEST'));
		}

		try
		{
			$publicKeyCredentialRequestOptions = unserialize(base64_decode($encodedOptions));
		}
		catch (Exception $e)
		{
			Log::add('Invalid plg_system_webauthn.publicKeyCredentialRequestOptions in the session', Log::NOTICE, 'webauthn.system');

			throw new RuntimeException(Text::_('PLG_SYSTEM_WEBAUTHN_ERR_CREATE_INVALID_LOGIN_REQUEST'));
		}

		if (!is_object($publicKeyCredentialRequestOptions) || !($publicKeyCredentialRequestOptions instanceof PublicKeyCredentialRequestOptions))
		{
			throw new RuntimeException(Text::_('PLG_SYSTEM_WEBAUTHN_ERR_CREATE_INVALID_LOGIN_REQUEST'));
		}

		return $publicKeyCredentialRequestOptions;
	}

	/**
	 * Get the WebAuthn library's Server object which facilitates WebAuthn operations
	 *
	 * @return  Server
	 * @throws  Exception
	 * @since    __DEPLOY_VERSION__
	 */
	private static function getWebauthnServer(): Server
	{
		$app      = Factory::getApplication();
		$siteName = $app->get('sitename');

		// Credentials repository
		$repository = self::getCredentialsRepository();

		// Relaying Party -- Our site
		$rpEntity = new PublicKeyCredentialRpEntity(
			$siteName,
			Uri::getInstance()->toString(['host']),
			self::getSiteIcon()
		);

		$server = new Server($rpEntity, $repository, null);

		/**
		 * =============================================================================================================
		 * Note about the metadata repository.
		 * =============================================================================================================
		 *
		 * We do not need to implement an MDS repo since we are not asking for the attestation metadata in this plugin.
		 * If you need to use this plugin in a high security environment you need to fork this plugin and do two things:
		 *
		 * 1. Change ATTESTATION_CONVEYANCE_PREFERENCE_NONE to ATTESTATION_CONVEYANCE_PREFERENCE_DIRECT or
		 *    ATTESTATION_CONVEYANCE_PREFERENCE_INDIRECT in the getPubKeyCreationOptions() method.
		 * 2. Implement your own Metadata Statement (MDS) repository and set it here, e.g.
		 *    ```php
		 *    $server->setMetadataStatementRepository(new MyMDSRepository());
		 *    ```
		 * The implementation of the MDS repository is considered out-of-scope since you'd need the MDS from the
		 * manufacturer(s) of your authenticator.
		 *
		 * @see https://webauthn-doc.spomky-labs.com/deep-into-the-framework/attestation-and-metadata-statement
		 */

		// Ed25519 is only available with libsodium
		if (!function_exists('sodium_crypto_sign_seed_keypair'))
		{
			$server->setSelectedAlgorithms(['RS256', 'RS512', 'PS256', 'PS512', 'ES256', 'ES512']);
		}

		return $server;
	}

	/**
	 * Get the credentials repository
	 *
	 * @return  CredentialRepository
	 *
	 * @since   __DEPLOY_VERSION__
	 */
	private static function getCredentialsRepository(): CredentialRepository
	{
		if (self::$credentialsRepository !== null)
		{
			return self::$credentialsRepository;
		}

		self::$credentialsRepository = new CredentialRepository;

		return self::$credentialsRepository;
	}
}
